shader_type spatial;

uniform sampler2D DEPTH_TEXTURE : hint_depth_texture, filter_linear_mipmap;
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_nearest;
uniform sampler2D NORMAL_TEXTURE : hint_normal_roughness_texture,
                                   filter_nearest;

uniform float lineHighlight = 0.2;
uniform float lineShadow = 0.55;

float GetLinearDepth(vec2 sUV, sampler2D depthTexture, mat4 invProjectionMat) {
  float depth = texture(depthTexture, sUV).x;
  vec3 ndc = vec3(sUV * 2.0 - 1.0, depth);
  vec4 view = invProjectionMat * vec4(ndc, 1.0);
  view.xyz /= view.w;
  return -view.z;
}

vec3 GetNormal(vec2 uv, sampler2D normalTexture) {
  vec3 normal = texture(normalTexture, uv).rgb;
  normal = normal * 2.0 - 1.0;
  return normal;
}

float NormalEdgeIndicator(vec3 normalEdgeBias, vec3 normal, vec3 neighborNormal,
                          float depthDifference) {
  float normalDifference = dot(normal - neighborNormal, normalEdgeBias);
  float normalIndicator =
      clamp(smoothstep(-0.01, 0.01, normalDifference), 0.0, 1.0);
  float depthIndicator = clamp(sign(depthDifference * 0.25 + 0.0025), 0.0, 1.0);
  return (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;
}

void vertex() { POSITION = vec4(VERTEX.xy, 1.0, 1.0); }

void fragment() {
  vec2 texelSize = 1.0 / VIEWPORT_SIZE.xy;

  vec2 UVOffsets[4];
  UVOffsets[0] = SCREEN_UV + vec2(0.0, -1.0) * texelSize;
  UVOffsets[1] = SCREEN_UV + vec2(0.0, 1.0) * texelSize;
  UVOffsets[2] = SCREEN_UV + vec2(1.0, 0.0) * texelSize;
  UVOffsets[3] = SCREEN_UV + vec2(-1.0, 0.0) * texelSize;

  float depthDifference = 0.0;
  float invDepthDifference = 0.5;
  float depth = GetLinearDepth(SCREEN_UV, DEPTH_TEXTURE, INV_PROJECTION_MATRIX);

  float safeDepth = depth + 0.0001;

  for (int i = 0; i < UVOffsets.length(); i++) {
    float dOff =
        GetLinearDepth(UVOffsets[i], DEPTH_TEXTURE, INV_PROJECTION_MATRIX);

    float relativeDiff = (dOff - depth) / safeDepth;

    depthDifference += clamp(relativeDiff, 0.0, 1.0);

    invDepthDifference += depth - dOff;
  }
  invDepthDifference = clamp(invDepthDifference, 0.0, 1.0);
  invDepthDifference =
      clamp(smoothstep(0.9, 0.9, invDepthDifference) * 10.0, 0.0, 1.0);

  depthDifference = smoothstep(0.25, 0.3, depthDifference);

  float normalDifference = 0.0;
  vec3 normal = GetNormal(SCREEN_UV, NORMAL_TEXTURE);
  vec3 normalEdgeBias = (vec3(1.0, 1.0, 1.0));
  for (int i = 0; i < UVOffsets.length(); i++) {
    vec3 nOff = GetNormal(UVOffsets[i], NORMAL_TEXTURE);
    normalDifference +=
        NormalEdgeIndicator(normalEdgeBias, normal, nOff, depthDifference);
  }
  normalDifference = smoothstep(0.2, 0.25, normalDifference);
  normalDifference = clamp(normalDifference - invDepthDifference, 0.0, 1.0);

  float innerLines = clamp(normalDifference - depthDifference, 0.0, 1.0);
  ALBEDO = texture(SCREEN_TEXTURE, SCREEN_UV).rgb;

  ALBEDO += innerLines * lineHighlight;
  ALBEDO -= depthDifference * lineShadow;
}

// void light() {
//	// Called for every pixel for every light affecting the material.
//	// Uncomment to replace the default light processing function with this
//one.
// }
